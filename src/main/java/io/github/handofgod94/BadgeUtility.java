package io.github.handofgod94;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.Optional;

import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;

import org.apache.pdfbox.pdmodel.font.PDFont;
import org.apache.pdfbox.pdmodel.font.PDMMType1Font;

import io.github.handofgod94.domain.Badge;

/**
 * Utility class for generating badges.
 */
public class BadgeUtility {

  // jacoco csv report column number
  public static final int INSTRUCTION_MISSED_COL_NO = 3;
  public static final int INSTRUCTION_COVERED_COL_NO = 4;
  public static final int BRANCH_MISSED_COL_NO = 5;
  public static final int BRANCH_COVERED_COL_NO = 6;
  public static final int LINE_MISSED_COL_NO = 7;
  public static final int LINE_COVERED_COL_NO = 8;
  public static final int COMPLEXITY_MISSED_COL_NO = 9;
  public static final int COMPLEXITY_COVERED_COL_NO = 10;
  public static final int METHOD_MISSED_COL_NO = 11;
  public static final int METHOD_COVERED_COL_NO = 12;

  /**
   * Calculates width of given string in pixels. Font size currently is 11,
   * default
   *
   * @param str input string needed
   * @return width in pixels as floating point value
   * @throws IOException if it's unable to calculate width from the badge label
   *                     input
   */
  public static float calculateWidth(String str) throws IOException {
    PDFont font = PDMMType1Font.HELVETICA_BOLD;
    int fontSize = 12;
    float width = ((font.getStringWidth(str) / 1000) * fontSize) + 10.0f;
    return width;
  }

  /**
   * Calculate coverage %age from csv report generated by jacoco.
   *
   * @param csvPath  Absolute path of csv report.
   * @param category enum representing the coverage category
   * @return integer value containing total coverage
   * @throws IOException           Unable to read jacoco csv report from config
   *                               location
   * @throws NumberFormatException Unable to parse %ages from jacoco reports
   * @see io.github.handofgod94.Badge.CoverageCategory
   */
  public static int calculateCoverage(String csvPath, Badge.CoverageCategory category)
      throws NumberFormatException, IOException {
    CSVReader reader = new CSVReaderBuilder(new FileReader(csvPath)).withSkipLines(1).build();

    long instructionsMissed = 0;
    long instructionsCovered = 0;
    int missedColNo = getMissedColNo(category);
    int coveredColNo = getCoveredColNo(category);

    String[] line;
    while (null != (line = reader.readNext())) {
      if (line[missedColNo] != null && !line[missedColNo].equals("")) {
        instructionsMissed += Integer.parseInt(line[missedColNo]);
      }

      if (line[coveredColNo] != null && !line[coveredColNo].equals("")) {
        instructionsCovered += Integer.parseInt(line[coveredColNo]);
      }
    }
    reader.close();

    // calculate coverage
    float totalInstructions = instructionsCovered + instructionsMissed;
    float coveragePercent = (instructionsCovered / totalInstructions) * 100.0f;
    int coverage = (int) Math.floor(coveragePercent);
    return coverage;
  }

  /**
   * Get correct color for the given %age range.
   * %age range is mapped to a particular color.
   * <table summary="Coverage to color map">
   *   <tr>
   *     <td>Coverage %age</td>
   *     <td>Color Enum</td>
   *   </tr>
   *   <tr>
   *     <td>[0, 40)</td>
   *     <td>RED</td>
   *   </tr>
   *   <tr>
   *     <td>[40, 50)</td>
   *     <td>ORANGE</td>
   *   </tr>
   *   <tr>
   *     <td>[50, 60)</td>
   *     <td>YELLOW</td>
   *   </tr>
   *   <tr>
   *     <td>[60, 70)</td>
   *     <td>YELLOWGREEN</td>
   *   </tr>
   *   <tr>
   *     <td>[70, 80)</td>
   *     <td>GREEN</td>
   *   </tr>
   *   <tr>
   *     <td>[80, 100)</td>
   *     <td>BRIGHTGREEN</td>
   *   </tr>
   * </table>
   *
   * @param coverage coverage percentage rounded off to nearest integer
   * @return An Enum for the given range
   * @see io.github.handofgod94.BadgeColors
   */
  public static BadgeColors getColorFromRange(int coverage) {
    if (coverage >= 0 && coverage < 40) {
      return BadgeColors.RED;
    } else if (coverage >= 40 && coverage < 50) {
      return BadgeColors.ORANGE;
    } else if (coverage >= 50 && coverage < 60) {
      return BadgeColors.YELLOW;
    } else if (coverage >= 60 && coverage < 70) {
      return BadgeColors.YELLOWGREEN;
    } else if (coverage >= 70 && coverage < 80) {
      return BadgeColors.GREEN;
    } else {
      return BadgeColors.BRIGHTGREEN;
    }
  }

  private static int getMissedColNo(Badge.CoverageCategory category) {
    switch (category) {
      case INSTRUCTION: return INSTRUCTION_MISSED_COL_NO;
      case LINE: return LINE_MISSED_COL_NO;
      case BRANCH: return BRANCH_MISSED_COL_NO;
      case COMPLEXITY: return COMPLEXITY_MISSED_COL_NO;
      case METHOD: return METHOD_MISSED_COL_NO;
      default: return INSTRUCTION_MISSED_COL_NO;
    }
  }

  private static int getCoveredColNo(Badge.CoverageCategory category) {
    switch (category) {
      case INSTRUCTION: return INSTRUCTION_COVERED_COL_NO;
      case LINE: return LINE_COVERED_COL_NO;
      case BRANCH: return BRANCH_COVERED_COL_NO;
      case COMPLEXITY: return COMPLEXITY_COVERED_COL_NO;
      case METHOD: return METHOD_COVERED_COL_NO;
      default: return INSTRUCTION_COVERED_COL_NO;
    }
  }

  public static final Optional<String> getFileExt(File file) {
    int i = file.getName().lastIndexOf(".");
    if (i > 0) {
      return Optional.of(file.getName().substring(i + 1));
    }
    return Optional.empty();
  }
}
